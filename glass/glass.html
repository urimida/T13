<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>인퉈뤡티브 연습용 사이트입니다.</title>

    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #ffffff;
        touch-action: none;
        overflow: hidden;
      }
      /* SVG는 화면에 표시되지 않지만 JS에서 접근 가능하도록 */
      svg#background-svg {
        position: absolute;
        width: 0;
        height: 0;
        pointer-events: none;
        visibility: hidden;
      }
    </style>

    <!-- p5.js 먼저 (setup/draw 등 p5 구조를 위해) -->
    <script src="../p5.min.js"></script>

    <!-- Tone.js (고급 오디오 처리) - 최신 버전 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- Matter.js (물리 엔진) -->
    <script src="../addons/matter.min.js"></script>

    <!-- poly-decomp (Matter.js의 concave polygon 처리용) -->
    <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>

    <!-- pathseg (SVG path를 Matter.js로 변환할 때 필요) -->
    <script src="https://cdn.jsdelivr.net/npm/pathseg@1.2.1/pathseg.min.js"></script>

    <!-- Liquid Glass 및 메인 스케치 -->
    <script src="liquid-glass.js"></script>
    <script src="sketch.js"></script>

    <!-- CSS 파일 별도 관리 -->
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <main></main>
    <script>
      (function () {
        const COUNT = 10;
        const TAG_W = 250;
        const TAG_H = 74;

        function createTag(index) {
          const el = document.createElement("div");
          el.className = "floating-tag";
          el.textContent = "# 태그 " + (index + 1);
          // 화면 밖으로 나가지 않도록 범위 제한
          const maxX = Math.max(0, window.innerWidth - TAG_W);
          const maxY = Math.max(0, window.innerHeight - TAG_H);
          const x = Math.floor(Math.random() * (maxX + 1));
          const y = Math.floor(Math.random() * (maxY + 1));
          el.style.left = x + "px";
          el.style.top = y + "px";
          document.body.appendChild(el);
          return el;
        }

        function spawnTags() {
          for (let i = 0; i < COUNT; i++) createTag(i);
        }

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", spawnTags);
        } else {
          spawnTags();
        }

        // 렌즈와 태그의 충돌 여부로 가시성 제어
        function intersectsCircleRect(cx, cy, cr, rx, ry, rw, rh) {
          const closestX = Math.max(rx, Math.min(cx, rx + rw));
          const closestY = Math.max(ry, Math.min(cy, ry + rh));
          const dx = cx - closestX;
          const dy = cy - closestY;
          return dx * dx + dy * dy <= cr * cr;
        }

        function updateVisibility() {
          const lens = window.currentLens;
          const tags = document.querySelectorAll(".floating-tag");
          if (!lens) {
            tags.forEach((el) => el.classList.remove("visible"));
          } else {
            tags.forEach((el) => {
              const rect = el.getBoundingClientRect();
              const hit = intersectsCircleRect(
                lens.x,
                lens.y,
                lens.r,
                rect.left,
                rect.top,
                rect.width,
                rect.height
              );
              if (hit) el.classList.add("visible");
              else el.classList.remove("visible");
            });
          }
          requestAnimationFrame(updateVisibility);
        }
        requestAnimationFrame(updateVisibility);
      })();
    </script>
  </body>
</html>
